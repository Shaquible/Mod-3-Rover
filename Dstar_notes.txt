d star notes for the people writing dstar 


f(s) = g(s) + h(s, s_goal)

f(s) = total cost
g(s) = cost to reach vertex from s_start
h(s, s_goal) = Heuristic for cost to reach vertex_goal from vertex (whats left)
^^^measurements taken from goal to start

choose between tie
new notation
f(s) <normal f(s), just g(s)>
path with lowest g value gets chosen

Overall formula
1. Initialize all nodes as unexpanded (g(s) = inf, rhs(s/=s_goal) = inf, rhs(s_goal)=0, k_m=0, s_last=s_start
2. Best first search from goal to start (until s_start is locally consistent)
3. Move to next best vertex
4. If any edges change
	a. Track how heuristics have changed (k_m = k_m + h(s_last, s_start))
	b. Update source nodes of changed edges (update rhs and queue position)
5. Repeat from 2

Step three: pick successor node based on lowest g score

Handling weight changes locally
- update lowest cost nodes first
- use priority queue, update nodes until the goal is first expanded
- create additional value: rhs()
- when rhs DOES NOT equal g, local inconsistency (over or under)
	- we then need to update (recompute) rhs and place the node on the priority queue

updating it:
 <min[g(s), rhs(s)] + h(s, s_start)>, min[g(s), rhs(s)] -> same as new notation just with the min values.

If overconsistent (g(s) > rhs())
	- new path cost is better
	- set g(s) = rhs(s)
	- update all predecessors of s

If underconsistent (g(s) < rhs(s))
	- Old path cost is better
	- set g(s) = inf
	- update all predecessors of s and s itself

Step 4a

Carrying over priority queue, when start node changes

s_last -> s_start: All heuristics lowered by at most h(s_last, s_start)
- when adding new nodes to the queue, increase total cost by h(s_last, s_start)

increase k_m = k_m + h(s_last, s_start):
	- <min[g(s), rhs(s)] + h(s, s_start) + k_m, min[g(s), rhs(s)]>

_______

 current = dlite.start
    changed,new_nodes = lidar.update_grid(rover.x, rover.y, rover.heading, rover.laser_distances, grid)

    #if there was a change in graph, set current = self.start
    print(changed) 
    if changed:
        dlite.km += dlite.heuristics(current,dlite.start)
        current = dlite.start
        for n in new_nodes:
        #go thru all nodes with changes then update vertex for each?
            dlite.update_vertex(n)
        dlite.get_shortest_path()
    path = [dlite.start] # list of path nodes for testing
    dlite.get_shortest_path()
    
    while dlite.start != dlite.goal:
        
        #change start to neighbouring node with lowest cost
        s_list = dlite.neighbours(dlite.start)
        min_neighbour = float('inf')
        for s in s_list:
            if dlite.cost(dlite.start,s) + dlite.g[s[0]][s[1]] < min_neighbour:
                min_neighbour = dlite.cost(dlite.start,s) + dlite.g[s[0]][s[1]]
                min_node = s

        dlite.start = min_node
        
        #move the rover to x and y
        #get x and y coordinates from node
        x = (dlite.start[0] - int(len(dlite.world_grid[0])/2)) * grid_res
        y = (dlite.start[1] - int(len(dlite.world_grid)/2)) * grid_res
        
        move.movement(x,y)
        path.append(dlite.start) #add to path
                #call update_grid
        changed,new_nodes = lidar.update_grid(rover.x, rover.y, rover.heading, rover.laser_distances, grid)

        #if there was a change in graph, set current = self.start
        print(changed) 
        if changed:
            dlite.km += dlite.heuristics(current,dlite.start)
            current = dlite.start
            for n in new_nodes:
            #go thru all nodes with changes then update vertex for each?
                dlite.update_vertex(n)
            dlite.get_shortest_path()

        dlite.get_shortest_path()
        print(path)
    

d star notes for the people writing dstar 


f(s) = g(s) + h(s, s_goal)

f(s) = total cost
g(s) = cost to reach vertex from s_start
h(s, s_goal) = Heuristic for cost to reach vertex_goal from vertex (whats left)
^^^measurements taken from goal to start

choose between tie
new notation
f(s) <normal f(s), just g(s)>
path with lowest g value gets chosen

Overall formula
1. Initialize all nodes as unexpanded (g(s) = inf, rhs(s/=s_goal) = inf, rhs(s_goal)=0, k_m=0, s_last=s_start
2. Best first search from goal to start (until s_start is locally consistent)
3. Move to next best vertex
4. If any edges change
	a. Track how heuristics have changed (k_m = k_m + h(s_last, s_start))
	b. Update source nodes of changed edges (update rhs and queue position)
5. Repeat from 2

Step three: pick successor node based on lowest g score

Handling weight changes locally
- update lowest cost nodes first
- use priority queue, update nodes until the goal is first expanded
- create additional value: rhs()
- when rhs DOES NOT equal g, local inconsistency (over or under)
	- we then need to update (recompute) rhs and place the node on the priority queue

updating it:
 <min[g(s), rhs(s)] + h(s, s_start)>, min[g(s), rhs(s)] -> same as new notation just with the min values.

If overconsistent (g(s) > rhs())
	- new path cost is better
	- set g(s) = rhs(s)
	- update all predecessors of s

If underconsistent (g(s) < rhs(s))
	- Old path cost is better
	- set g(s) = inf
	- update all predecessors of s and s itself

Step 4a

Carrying over priority queue, when start node changes

s_last -> s_start: All heuristics lowered by at most h(s_last, s_start)
- when adding new nodes to the queue, increase total cost by h(s_last, s_start)

increase k_m = k_m + h(s_last, s_start):
	- <min[g(s), rhs(s)] + h(s, s_start) + k_m, min[g(s), rhs(s)]>
